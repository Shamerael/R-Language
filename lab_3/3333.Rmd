---
title: "ЛР 3"
author: "Спиридонова Алина"
date: "18 12 2020"
output: word_document
---

```{r setup, include=FALSE}
# Загрузка библиотек
library('knitr')
library('lmtest')     # тесты остатков: bptest(), dwtest()
library('broom')      # трансформации данных: augment()
library('car')        # тест на мультиколинеарность: vif()
library('sandwich')   # оценки модели с поправкой на гетероскедастичность: vcovHC()

#счётчик для таблиц
table.num <- 1
#счётчик для рисунков
pic.num <- 1

knitr::opts_chunk$set(echo = TRUE)
```


##Импорт данных
Импортируем объекты, сохраненные в рабочем пространстве по итогу ЛР№2






```{r import, echo = FALSE}
load('test_lab2_Спиридонова.RData')
```
```{r, echo = FALSE}
ls() #просмотр списка объектов

kable(names(models.list)) #название моделей в списке
```




# 2. Графики остатков  ---------------------------------------------------------

```{r, echo = FALSE}
#  цикл по моделям в списке models.list
for (i in 1:length(models.list)) {
    # открываем вывод в файл
    png(paste('RPlot', i, '.png', sep = ''), height = 500, width = 500)
   # делим полотно на четыре части
    par(mfrow = c(2, 2))
    
    # рисуем 4 графика для одной и той же модели
    plot(models.list[[i]], 1)
    plot(models.list[[i]], 2)
    plot(models.list[[i]], 3)
    plot(models.list[[i]], 5)
    # добавляем общий заголовок с названием модели
    mtext(paste('Остатки модели ', names(models.list)[i], sep = ''), 
          side = 3, line = -2, outer = TRUE, cex = 1.2)
    par(mfrow = c(1, 1))
    
    # закрываем вывод в файл
    dev.off()
}
```
По графику Кука мы заметили, что более всего отклоняются расстояния Кука для регионов с номерами 34 и 68.
```{r, echo = FALSE}
# Регионы с номерами 34 и 68
DF[rownames(DF) %in% c(34, 68), c('Region', 'FO')]

# работаем с четвёртой моделью
# найдём расстояния Кука для влияющих регионов
h <- augment(models.list[[3]], reg.df)
lev <- h[rownames(reg.df) %in% c(34, 68), '.cooksd', drop = F]


# медианное F-значение - порог для отсечения влияющих
n <- nrow(reg.df)
p <- nrow(summary(fit.11.fo)$coeff) - 1
f.median <- qf(1 - 0.5, df1 = p, df2 = n - p)
# порог = 1
cut.1 <- 1
# порог = 4 / n
cut.4.n <- round(4 / nrow(reg.df), 2)

# сравниваем расчётные значения с порогами
cbind(leverage = round(lev,2), f.median = round(f.median,2),
      cut.1, cut.4.n)

```

По итогу расстояние кука для каждого наблюдения меньше чем медианный фквартить и меньше чем 1, но больше чем жесткий порог отсечение 4/n. Можно сказать что данные регионы не аномальны для модели и не оказывают серьезного влияния на ее расположение.


Выдвигаем гипотезу H0 о том, что среднее по остаткам равно 0 и альтернативную гипотезу H1.

# 3. Проверка равенства среднего остатков нулю  --------------------------------
```{r, echo = FALSE}
# номер модели
i <- 3
# t-тест для среднего
t.test(models.list[[i]]$residuals, mu = 0, alternative = 'two.sided')
```
В нашем слечае $p-value = 1$ и это больше чем 0,05, из чего мы можем сделать вывод, что H0 не отвергается и среднее остатков моделей равно 0.
 
# 3. Проверка постоянства среднего остатков ------------------------------------
#```{r, echo = FALSE}
# номер модели
#i <- 3
# первая половина остатков
#res.s1 <- fit.11.fo$остатки[1:(n / 2)]
# вторая половина остатков
#res.s2 <- fit.11.fo$остатки[(n / 2):n]
# t-тест для равенства средних
#t.t <- t.test(res.s1, res.s2, alternative = 'two.sided')
#res <- c(t.t$statistic, t.t$p.value)
#names(res) <- ('t.расч', 'Р-значение')
#round(res, 4)
#```

Остатки пустые => нет смысл проводить тесты на гетероскедантичность.

# 4. Обнаружение автокорреляции  -----------------------------------------------
Выдвиигаем две гипотезы:  H0 о том, что автокорреляция есть и альтернативную гипотезу H1 о том, что автокорреляции нет. Проверяем только гипотезу первого порядка

```{r,  echo = FALSE}
# номер модели в списке
i <- 3

# тест Дарбина-Уотсона на автокорреляцию
dwtest(models.list[[i]], alternative = 'two.sided')

# автокорреляционный коэффициент первого порядка для остатков
n <- nrow(reg.df)
cor.test(x = models.list[[i]]$residuals[1:(n - 1)],
         y = models.list[[i]]$residuals[2:n])

```
# 6. Переоценка параметров модели с учётом ошибок -----------------------------
```{r,  echo = FALSE}
# оценки параметров модели по МНК. для примера: модель 1
i < - 1

# исходные коэффициенты и их стандартные ошибки
coeftest(models.list[[i]])

# робастные оценки стандартных ошибок моделей
# vcovHC(): оценка ковариационной матриц, устойчивая к гетероскедастичности
# vcovHAC(): оценка ковариационной матриц, устойчивая к гетероскедастичности
# и автокорреляции
coeftest(models.list[[i]], vcov. = vcovHAC(models.list[[i]])) # гетероскедастичность и автокорреляция
# NB: сами оценки параметров не меняются,
# меняются их стандартные ошибки, и выводы по значимости могут измениться

```
Мы можем заметить, что практически все переменные значимы




# 7. Обнаружение мультиколлинеарности  -----------------------------------------
```{r,  echo = FALSE}
# VIF-тест на мультиколлинеарность факторов 
#  NB: применяется для множественной регрессии с непрерывными факторами
round(vif(models.list[[2]]), 2)
```

















